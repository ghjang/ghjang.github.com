---
layout: post
title: "Fold it the way you like"
description: ""
category: Computer Programming
tags: [Functional Programming, C++ TMP]
---
{% include JB/setup %}

## What is Fold about?

Functional Programming과 관련하여 언급되는 **Fold**에 대해서는 인터넷 상의 여러 글들을 통해서 볼 수가 있었다. 그러다가 좀 그나마 자세하게 이해하게된 시점은 아래의 글을 읽고 나서이다. 이 글에서는 수치 데이터를 다루는 `FoldRight`에 대한 설명을 포함하고있다:

+ [What Does Haskell Have to Do with C++?](http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/)

Fold는 사전적인 의미로는 **접다**이다. *'접기는 뭘 접는다는 것이여?'*

Fold를 간략하게 요약하면 '입력 열을 특정 연산에 대해서 접어서 하나의 결과값을 생성(accumulation)' 하는 것이라고 할 수 있겠다. 좀더 단순하게 설명하면 '입력열을 받아서 하나의 결과생성' 정도 이겠다.

Fold는 두가지가 있다고 한다: **FoldLeft, FoldRight**

### FoldRight

F를 두개의 인자를 받고 1개의 값을 리턴하는 이항함수라고 하자. 편의를 위해서 F를 op(operation)라고하자. 't0,t1,...,tn'은 함수에 인자로 전달될 값의 열이라고 하자. 'init'는 어떤 초기값에 해당하는 것이라고 하자. 이상태에서 FoldRight를 추상적인 개념으로 다음과 같이 표현할 수 있겠다:

+ (t0 op (t1 op (t2 op ...(tn op init)...)

가만히 보면 괄호문자 '('와 ')'가 전체 인자 열에서 우측에 우선하게 결합되어 있는 것을 볼 수 있다. 좀 어거지일 수도 있겠으나 이런 괄호가 우측으로 '접혀진' 것처럼 보이기에 Fold라고 부르는 것이 아닐까 싶기도 하다.

op는 무엇이던지 될 수 있겠다. 흔하게드는 예가 '+', '-' 연산이다.

### FoldLeft

먼저 설명한 FoldRight에서의 가정과 같다고 하면, FoldLeft를 추상적인 개념으로 다음과 같이 표현할 수 있겠다:

+ (...(init op t0) op t1) op t2)... op tn)

전체 인자 열에서 좌측에 우선하게 결합되어 있는 것을 확인할 수 있다.

특정 연산은 **교환법칙**이 성립하지 않는다. 교환칙법이 성립하는 연산의 경우는 FoldLeft, FoldRight의 결과가 동일하지만 성립하지 않는 연산의 경우는 사용에 주의해야만 한다.

---

## Runtime Fold: std::accumulate

C++ STL에 Fold(accumulation) 기능을 하는 것이 바로 `std::accumulate` 알고리즘이다. 이항함수를 받아들이도록 오버로드된 버전은 보통 아래와 같이 구현된다고 한다:

{% highlight cpp %}
template<class InputIt, class T, class BinaryOperation>
T accumulate(InputIt first, InputIt last, T init, BinaryOperation op)
{
    for (; first != last; ++first) {
        init = op(init, *first);
    }
    return init;
}
{% endhighlight %}

천천히 살펴보면 이런 구현은 FoldLeft 형태임을 알 수 있다.

사용예는 다음과 같다:

{% highlight cpp %}
#include <numeric>

//...

std::vector<int> v = { 1, 2, 3, 4, 5 };
auto sum = std::accumulate(
                    v.begin(), v.end(),
                    0, // init
                    [](int lhs, int rhs) { return lhs + rhs; }
            );
REQUIRE(15 == sum); // refer to catch.hpp
{% endhighlight %}

---

## Compile-time Fold

나름 자체적으로 구현한 Compile-time 버전의 FoldRight와 FoldLeft 코드는 아래와 같다. 

### FoldRight

{% highlight cpp %}
template <typename T>
struct Identity
{
    using type = T;
};

template <typename T>
using type_is = Identity<T>;

//...

template <template <typename, typename> class F, typename init, typename... list>
struct FoldRight;

template <template <typename, typename> class F, typename init>
struct FoldRight<F, init> : type_is<init>
{ };

template <template <typename, typename> class F, typename init, typename head, typename... tail>
struct FoldRight<F, init, head, tail...>
{
    using type = typename F<head, typename FoldRight<F, init, tail...>::type>::type;
};

template <template <typename, typename> class F, typename init, typename... list>
struct FoldRight<F, init, std::tuple<list...>>
        : FoldRight<F, init, list...>
{ };
{% endhighlight %}

사용예는 다음과 같다.

{% highlight cpp %}
template <typename lhs, typename rhs>
struct IntegralConstantSum;

template <typename T1, T1 v1, typename T2, T2 v2>
struct IntegralConstantSum<std::integral_constant<T1, v1>, std::integral_constant<T2, v2>>
            : std::integral_constant<decltype(v1 + v2), v1 + v2>
{ };

//...

template <int i>
using int_c_t = std::integral_constant<int, i>;

//...

using sum_t = typename FoldRight<
                            IntegralConstantSum,
                            int_c_t<0>,  // init
                            int_c_t<1>,
                            int_c_t<2>,
                            int_c_t<3>,
                            int_c_t<4>,
                            int_c_t<5>
                        >::type;
static_assert(sum_t() == 15, "1 + (2 + (3 + (4 + (5 + 0)))) = 15");
{% endhighlight %}

### FoldLeft

{% highlight cpp %}

// NOTE: refer to the above description.

//...

template <template <typename, typename> class F, typename init, typename... list>
struct FoldLeft;

template <template <typename, typename> class F, typename last>
struct FoldLeft<F, last> : type_is<last>
{ };

template <template <typename, typename> class F, typename init, typename head, typename... tail>
struct FoldLeft<F, init, head, tail...>
        : FoldLeft<F, typename F<init, head>::type, tail...>
{ };

template <template <typename, typename> class F, typename init, typename... list>
struct FoldLeft<F, init, std::tuple<list...>>
        : FoldLeft<F, init, list...>
{ };
{% endhighlight %}

사용예는 다음과 같다.

{% highlight cpp %}
using sum_t = typename FoldLeft<
                            IntegralConstantSum,
                            int_c_t<0>,  // init
                            int_c_t<1>,
                            int_c_t<2>,
                            int_c_t<3>,
                            int_c_t<4>,
                            int_c_t<5>
                        >::type;
static_assert(sum_t() == 15, "(((((0 + 1) + 2) + 3) + 4) + 5) = 15");
{% endhighlight %}
